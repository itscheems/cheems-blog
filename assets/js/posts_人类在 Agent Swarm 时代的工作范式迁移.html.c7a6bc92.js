"use strict";(self.webpackChunkcheems_blog=self.webpackChunkcheems_blog||[]).push([[6964],{2762(e,p,a){a.r(p),a.d(p,{comp:()=>s,data:()=>r});var t=a(641);const n={},s=(0,a(6262).A)(n,[["render",function(e,p){return(0,t.uX)(),(0,t.CE)("div",null,[(0,t.Q3)(" more "),p[0]||(p[0]=(0,t.Fv)('<h1 id="人类在-agent-swarm-时代的工作范式迁移" tabindex="-1"><a class="header-anchor" href="#人类在-agent-swarm-时代的工作范式迁移"><span>人类在 Agent Swarm 时代的工作范式迁移</span></a></h1><p>随着现在 Agent Swarm 的兴起，人类的身份逐渐变化。旧的定义是人写代码，AI 辅助（AI 当助理）现在变成了人设计系统，AI 执行。 即从执行者+监督者，变成了设计师+委托人+决策者</p><h2 id="观察到的一些现象" tabindex="-1"><a class="header-anchor" href="#观察到的一些现象"><span>观察到的一些现象</span></a></h2><p>比如现在的 gpt-5.2 / gpt codex 5.2 这一些模型，让他做个简单的“助手型任务”，比如翻译一些注释、改一些变量名使其满足可读性规范、又或是其他简单任务（模仿一个文件的风格写另一个文件等），它会思考20秒才给出结果，反应迟钝，看起来很懒惰，作为助手，它很糟糕。</p><p>但转折来了，如果你给他一个比较模糊/复杂的任务，比如“研究一下这个依赖库在 Linux ARM 架构上构建失败的原因，并帮我写一个补丁”，它会像一个真正的人类一样连续工作个十几、几十分钟不等。它会自己去查文档、读源码、尝试复现并分析原因，最后给出方案。</p><p>所以刚开始用 gpt-5.2 / codex 给我的第一感觉就是“慢”，实际上我不需要盯着他工作十几分钟。但随着使用次数的增加，我发现 gpt 5.2 在处理一些复杂问题时，它的推理会很细致，发现了很多我没发现的细节，于是开始转变看法。或许我的工作范式才是导致工作流变慢的原因。</p><h2 id="注意单点瓶颈" tabindex="-1"><a class="header-anchor" href="#注意单点瓶颈"><span>注意单点瓶颈！</span></a></h2><p>过去两年，像 Cursor、Copilot 等编辑器在侧边栏与 AI 聊天，被视为标准范式，但只要侧边栏还在，人类的注意力就总会下意识退回到人类问一些问题，AI 就补全一些代码。或者是把代码从右边复制到左边的一个过程。这种模式让人产生一种“在用 AI”的幻觉。<strong>可实际上人是这个链路中最慢的组件</strong>，把自己锁死在“人在回路中”的瓶颈位置。</p><p><strong>这种模式不仅慢，而且有毒，它会让你沉迷即时反馈的快感，让你忽略了真正的效率提升。</strong></p><blockquote><p>我没有在说侧边栏不好，我是在思考，是不是真的要把注意力从代码层面开始转移。codex app 的无代码界面我也十分不习惯，但随后我了解到他们这些工具的设计理念之后，我反过来思考我都工作模式，或许这些工具一开始不完美，或许以后也是要支持代码/文件浏览功能，但无论如何，旧的编码方式让人处在木桶短板地位这个说法我认为是没错的。</p></blockquote><p>人类的大脑是单线程的，一次几乎只能处理一个文件（或一个 feature），侧边栏模式是为了人类单线程工作而设计的。</p><p>但 AI 是可以并发的，如果卡在人类的瓶颈，那这完全浪费了 AI 的并发能力。</p><h2 id="范式的转变" tabindex="-1"><a class="header-anchor" href="#范式的转变"><span>范式的转变</span></a></h2><p>答案是什么？我认为是要像“工厂模式”那样，才是未来。</p><p>以前的助手模式下，我是钢铁侠，AI 是贾维斯。虽然贾维斯很强，但还是会围着我转，我停下来，他也停下来。即上述说的“单点瓶颈”。</p><p>而工厂模式下，我是工厂主，我负责设计好流水线，按下按钮，多个 AI Agent 并发工作（或 sub Agent</p><p>打个比方：</p><ul><li>Agent 1 负责拆需求</li><li>Agent 2 负责写实现</li><li>Agent 3 负责写测试</li><li>Agent 4 负责 code review</li><li>Agent 0 甚至可以调度这另外几个 Agent</li></ul><p>你不需要盯着他们，可以去做别的事</p><h2 id="关于-开发体验" tabindex="-1"><a class="header-anchor" href="#关于-开发体验"><span>关于“开发体验”</span></a></h2><p>在以前，报错信息、日志是给人看的，会拿来排查故障，确定问题；用红色高亮标识爆错，用英文/中文写“=== failed to get xxx ===”，讲究可读性。</p><p>现在“开发体验”的语义也开始转变。以前 DX(Development Experience)指的是开发者体验，现在分化为 HDX(Human DX) 和 ADX(Agent DX)。</p><p>有些观点是：可以为了 ADX 牺牲一些 HDX。怎么做呢？比如日志采用结构化的 JSON 或者某种冗长但包含详细堆栈细节的格式。这种信息人类读起来体验可能会很差，但对 AI 十分友好。</p><p>这是对的，因为现在绝大部分报错都可以通过 Agent 自动捕获并且修复，而人类会更少的（逐行）阅读日志。如果为了人类感官上的可读性好，而牺牲 Agent 的效率，那是本末倒置。</p><p>HDX 不再等于“可读性”，而等于“可干预性”。也就是说，日志不需要人能顺眼读，报错不需要人第一眼看懂，代码甚至不需要人能轻松 follow。但必须满足一件事：人类能在 5 分钟内接管系统，并施加“高层干预”。</p><p>如果 ADX 走到，只有 AI 看得懂，人类失去全局理解能力，那不是进化，是技术性失明。</p><p>最健康的形态是：</p><ul><li>底层：为 Agent 优化</li><li>顶层：为 Human 决策优化</li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><p>AI 发展太快，一周、一月一个样，从 GPT-4 到 GPT-5.2 只用了两年，但模型效果天翻地覆。</p><p>任何试图“维护旧功能”的行为，在这个高速发展的时代，都是在自杀。</p><p>人也一样，如果不自己颠覆自己，别人就会来颠覆你。</p>',32))])}]]),r=JSON.parse('{"path":"/posts/%E4%BA%BA%E7%B1%BB%E5%9C%A8%20Agent%20Swarm%20%E6%97%B6%E4%BB%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%8C%83%E5%BC%8F%E8%BF%81%E7%A7%BB.html","title":"人类在 Agent Swarm 时代的工作范式迁移","lang":"zh-CN","frontmatter":{"date":"2026-02-08T00:00:00.000Z","excerpt":"<p>随着现在 Agent Swarm 的兴起，人类的身份逐渐变化。旧的定义是人写代码，AI 辅助（AI 当助理）现在变成了人设计系统，AI 执行。即从执行者+监督者，变成了设计师+委托人+决策者</p>"},"git":{"createdTime":1770538325000,"updatedTime":1770538325000,"contributors":[{"name":"itscheems","username":"itscheems","email":"94773058+itscheems@users.noreply.github.com","commits":1,"url":"https://github.com/itscheems"}]},"readingTime":{"minutes":4.98,"words":1494},"filePathRelative":"posts/人类在 Agent Swarm 时代的工作范式迁移.md"}')},6262(e,p){p.A=(e,p)=>{const a=e.__vccOpts||e;for(const[e,t]of p)a[e]=t;return a}}}]);